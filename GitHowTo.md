# Introduction #

The BLIS framework uses [git](https://git.wiki.kernel.org/index.php/Main_Page) for its version control. Much documentation has been written by others and is available on the `git` [documentation](https://git.wiki.kernel.org/index.php/GitDocumentation) page.

The primary purpose of this wiki page is to quickly familiarize newcomers to `git` with the commonly used commands they will need to work with the BLIS repository. It may also serve as a handy quick reference.

Here are some useful `git`-related links:

  * [git wikipedia entry](http://en.wikipedia.org/wiki/Git_%28software%29). If you are new to `git`, I recommend that you browse this page. It contains some important (and interesting) background information and introduces various concepts that will be needed to understand how `git` works.

  * [git user's manual](http://www.kernel.org/pub/software/scm/git/docs/user-manual.html). The main reference for using `git`.

  * [Everyday GIT With 20 Commands Or So](http://www.kernel.org/pub/software/scm/git/docs/everyday.html). A decent summary of everyday commands.

  * [git glossary of terms](https://git.wiki.kernel.org/index.php/GitGlossary). If you encounter any terminology you're unsure of, check here for an explanation.

BLIS will be of interest to primarily two audiences:

  * _Application developers_. These are the people who are developing or maintaining programs (or libraries) which would potentially make use of a BLIS library. These people are perhaps succinctly described as end-users of BLIS.

  * _Library developers_. These are the people who wish to develop BLIS libraries (via the BLIS framework). We also often refer to these people as _vendors_ since BLIS was designed to be a tool for, among others, hardware vendors seeking to provide BLAS-like libraries for their users.

There is also a third audience, _framework developers_, which refers to the group responsible for authoring, extending, and maintaining the BLIS framework itself. But for now, this group consists of very few individuals.

The `git` commands introduced here are organized based on who would need to use them. We cover the universally applicable commands first. Most application developers can be productive using only the commands in the first section. The second section covers additional commands needed by those who wish to (and have been given permission to) push their commits into the Google Code repository.



# Commands for all developers #



## clone ##

The [git-clone](http://www.kernel.org/pub/software/scm/git/docs/git-clone.html) command allows you to obtain a local copy of the code from an existing repository (the subversion equivalent of `svn checkout`). In our case, your command would look like this:
```
  $ git clone https://<username>@code.google.com/p/blis/ 
```
Alternatively, you could create a `.netrc` file in your home directory with the contents:
```
  machine code.google.com login <username>@gmail.com password <password>
```
where `<username>` is your Google login name and `<password>` is the [password](http://code.google.com/hosting/settings) generated by Google Code. (The password of this file is used to automatically authenticate you if you were to ever push changes into the Google Code repository.) Be sure to change the permissions of this file so that only you can read or write it:
```
  $ chmod 0600 ~/.netrc
```
With this `.netrc` file in place, you can now use the shorter `clone` command (note the URL here does not contain your username):
```
  $ git clone https://code.google.com/p/blis/
```
These two ways of obtaining the code are also explained on the project's [Source](http://code.google.com/p/blis/source/checkout) tab.

NOTE: The `clone` command, in addition to giving you a working copy of the entire repository, places a `.git` directory at the top level of the tree. Subversion users will recognize this as similar to the `.svn` directories, the only difference being that there exists only one `.git` directory per working copy (residing at the top level).



## pull ##

The [git-pull](http://www.kernel.org/pub/software/scm/git/docs/git-pull.html) command allows you to fetch changes from a remote repository and merge them into your current working tree. (`git-pull` is actually a shortcut for two other `git` commands, [git-fetch](http://www.kernel.org/pub/software/scm/git/docs/git-fetch.html) and [git-merge](http://www.kernel.org/pub/software/scm/git/docs/git-merge.html).) This is similar to subversion's `svn update` command.

As long as you have your "master" branch currently checked out (most basic users of git will use only their master branch), you can pull in all changes to master branch of the repository of origin (the one at Google Code) by simply executing:
```
  $ git pull
```
This is short for:
```
  $ git pull origin master
```
While the `git-pull` command has many other options, this simple usage should be sufficient for most developers.



## log ##

[git-log](http://www.kernel.org/pub/software/scm/git/docs/git-log.html) can be used to show commit logs:
```
  $ git log
```
This command is _very_ flexible and well beyond the scope of discussion here. Please reference the full man page or documentation for the command for specific details.



# Commands for library developers #



## add ##

[git-add](http://www.kernel.org/pub/software/scm/git/docs/git-add.html) is used to place local changes in the index, previously known as "the cache", also sometimes called the "staging area". (A somewhat more complete description of staging can be found [here](http://git-scm.com/book/en/Getting-Started-Git-Basics#The-Three-States).)
```
  $ git add .
  $ git add <file>
  $ git add <directory>
```
Wildcards are also accepted:
```
  $ git add *.[ch]
```
This command would all add `.c` and `.h` files in the current directory.

When adding directories, the behavior of `git-add` is inherently recursive. When recursing, the `git` command will not add "ignored" files, which typically are those specified in the `.gitignore` file found at the top-level of the tree. (Typically, these ignored files include build products such as `.o` object files.)

NOTE: The `git-add` command differs significantly from that of subversion's `svn add`. Specifically, with subversion, modified files that are already being tracked are automatically "staged", in the sense that they will be committed upon running `svn commit`, and so one needs only run `svn add` on untracked files. By contrast, when using `git`, one must manually stage (add) all local changes, not just those corresponding to new files that are not yet being tracked.

In order to better understand the impact of `git-add` it helps to first list the three types of file changes that `git` may encounter:

  * A tracked file that has been modified.
  * A tracked file that is no longer present.
  * A new, untracked file.

No let's consider the following hypothetical changes to a hypothetical small project:

  1. You rename the file `TODO` to `TO-DO` (because you've always been undecided as to whether it was a "todo" list or a "to-do" list).
    * This can be thought of as (a) the creation of an untracked file `TO-DO`, and (b) the removal of the tracked file `TODO`.
  1. You edit the file `Makefile` in order to add some new `make` rules, comments, etc.
  1. You remove the file `INSTALL` because you've since migrated the file's contents a wiki instead.
  1. You add a new file, `LICENSE`, because you though it would be good to have a copy of the license in the top-level directory as well as within each source file.

(Take a moment and think about how each of these maps back to one of the three file changes above.)

We will now explain each variation of `git-add` in terms of the hypothetical changes described above. If we were to run:
```
  $ git add .
```
on the above project directory and then run `git status`, we would get:
```
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	new file:   TO-DO
#	modified:   Makefile
#	new file:   LICENSE
#
# Changes not staged for commit:
#   (use "git add/rm <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#	deleted:    TODO
#	deleted:    INSTALL
#
```
So what happened? `git` staged modifications to `Makefile` as well as detecting and staging the new (untracked) file `LICENSE`. But it only detected _half_ of the renaming of `TODO` to `TO-DO`, specifically the half corresponding to the creation of this "new" (untracked) file `TO-DO`. Here, `git-add` does not detect the half corresponding to the removal of the "old" (tracked) file `TODO`. This is key to understanding this particular mode of `git-add`; it does NOT stage deletions of tracked files.

Now let's consider an alternate invocation:
```
  $ git add --update
```
The idea here is that we want `git` to stage any and all changes to files it is already aware of. Running `git add --update` on the previously discussed project, followed by `git status`, would give us:
```
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	deleted:    TODO
#	modified:   Makefile
#	deleted:    INSTALL
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	TO-DO
#	LICENSE
```
Just like last time, `git-add` stages the modifications to `Makefile`. And again, only half of the renaming of `TODO` to `TO-DO` is staged, but this time it is the half corresponding to the deletion of `TODO` that is staged (because `TODO` is a tracked file), while the addition of `TO-DO` (which `git` treats as untracked since it is "new" to the repository) is left unstaged. Similarly, the fates of INSTALL and LICENSE are reversed this time: the removal of the former is staged while the addition of the latter is not (because they are tracked and untracked, respectively). This is all consistent with the general behavior of `--update`, which is to only update the index with changes to files that are already being tracked.

At this point, you might be thinking, "Why can't `git` just stage both halves of the renaming of `TODO`?" Actually, it can! `git` can even detect when _modified_ files have been renamed and record the change as a rename instead of separate new and deleted files. To activate this rename detection, one simply has to _tell_ `git` about both halves of the transaction. The easiest way to do this is to just use a third invocation of `git-add`:
```
  $ git add --all
```
This causes `git-add` to run in a sort of catch-all mode, resulting in the following `git status` output:
```
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	renamed:    TODO -> TO-DO
#	modified:   Makefile
#	new file:   LICENSE
#	deleted:    INSTALL
#
```
With this command, all of our changes are staged. And since `git` is staging both the new untracked `TO-DO` file and its older tracked counterpart, `TODO`, it can detect that they are the same file and thus record the two changes as being part of a single file move/rename.

To summarize:
  * `git add .` stages changes to tracked files as well the addition of untracked files, but does NOT stage the removal of files no longer present in the working tree.
  * `git add --update` stages changes to tracked files and also stages the removal of tracked files, but does NOT stage the addition of untracked files.
  * `git add --all` stages the union of the above two: changes to tracked files; removal of tracked files; and the addition of untracked files.



## reset ##

[git-reset](http://www.kernel.org/pub/software/scm/git/docs/git-reset.html) reset the index to the state of a specified commit (defaulting to the HEAD commit). This command is similar to that of subversion's `svn revert` on files that have been scheduled for addition.

To reset the index, use:
```
  $ git reset
```
If you want to reset the index _and_ recursively discard any changes in your working tree, use:
```
  $ git reset --hard
```
But use this command carefully, since there will be no way (unless your files were previously backed up) to recover these changes.



## rm ##

[git-rm](http://www.kernel.org/pub/software/scm/git/docs/git-rm.html) removes files from the index and the working tree:
```
  $ git rm <file>
```
Directories can be removed recursively, but you must use the `-r` option:
```
  $ git rm -r <directory>
```
These removals will take effect in the next commit after running `git-commit`.



## status ##

[git-status](http://www.kernel.org/pub/software/scm/git/docs/git-status.html) reports the status of the working tree (and the index).
```
  $ git status
```
Paraphrasing from the [git-status](http://www.kernel.org/pub/software/scm/git/docs/git-status.html) page, `git-status` shows you three types of information:

  1. paths that have differences between the index (staging area) and the HEAD commit of the local repository (i.e., changes that have already been staged)
  1. paths that exhibit differences between the working tree and the index (i.e., previously staged changes that are now out-of-date)
  1. paths in your working tree that are currently untracked by `git`

(1) captures what _would_ be committed upon running `git-commit` while (2) and (3) capture what you _could_ commit by first running `git-add` and then `git-commit`.

Please see the [explanation](GitHowTo#add.md) of `git-add` above for examples of `git-status` output.



## diff ##

[git-diff](http://www.kernel.org/pub/software/scm/git/docs/git-diff.html) shows the changes you've made but have not yet added (staged) to the index:
```
  $ git diff
```
If we instead accompany the command with the `--cached` option, `git` reports the changes currently staged in the index:
```
  $ git diff --cached
```



## commit ##

[git-commit](http://www.kernel.org/pub/software/scm/git/docs/git-commit.html) records staged changes from the index to the local repository, thus creating a new "commit" (or, in subversion-land, a new revision).
```
  $ git commit
```
This commits all changes currently staged in the index.

NOTE: When creating a new commit, the user is prompted to make a log entry. The text editor that is launched is based on the value of `GIT_EDITOR`, `VISUAL`, or `EDITOR` environment variables (checking them in that order). Please make sure one of these variables is set in your shell before committing.

It is possible to specify the commital of only some staged files:
```
  $ git commit <file1> <file2>
```
This creates a new commit with only the changes in `<file1>` and `<file2>`. Any other staged changes are not included in the commit, but remain in the index.

When creating a new commit, one can ask `git` to call `git-add` on your behalf, which may be more natural in some situations. Suppose we would normally execute the following:
```
  <edit foo.c>
  $ git add foo.c
  $ git rm bar.c
  $ git commit
```
If you wished to simultaneously stage changes (including removals of tracked files), one could use the `-a` option:
```
  <edit foo.c>
  $ rm bar.c
  $ git commit -a foo.c bar.c
```
This option is useful if you are making a commit that does not involve extensive and careful staging.



## push ##

[git-push](http://www.kernel.org/pub/software/scm/git/docs/git-push.html) updates a remote repository using the contents of your local repository. In our case, there is typically only one "remote" repository, which is the one residing on the Google Code servers. After creating some number of commits to your local repository, you would typically want to share those changes. Thus, you would run `git-push`:
```
  $ git push
  $ git push origin master
```
This sends all of the commits on the "master" branch to the origin repository (the Google Code repository from which you originally cloned). If you want to also send the tags that you made, use the `--tags` options:
```
  $ git push --tags
```



# Other topics #



## Reverting changes to a file ##

Suppose you made some changes to a file but then decide that you want to start over. You can do so with the [git-checkout](http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html) command:
```
  $ git checkout HEAD foo.c
```
This tells `git` that you want to "checkout" the version of `foo.c` from the HEAD (i.e., the head of the current branch, typically "master") of the repository.

This is equivalent to `svn revert` when a subversion user is trying to revert a tracked file back to the contents as of the previous commit.



## Resolving conflicts ##

Sometimes a merge (typically initiated via [git-pull](http://www.kernel.org/pub/software/scm/git/docs/git-pull.html)) introduces changes (made by other developers, for example) that conflict with changes in your working tree. This results in a conflict. Paraphrasing the [user's manual](http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#resolving-a-merge), `git-status` will tell you which files are still not merged:
```
  $ git status | grep unmerged
  unmerged: foobar.c
```
Files with conflicts will have conflict markers in them, such as:
```
  <<<<<<< HEAD:foobar.c
  // Comment A.
  =======
  // Comment B.
  >>>>>>> 77976da35a11db4580b80ae27e8d65caf5208086:foobar.c
```
Simply edit the file to manually resolve the conflict (i.e., decide which text to keep/delete at each conflict marker, and also delete the comment markers themselves), and then run:
```
  $ git add foobar.c
  $ git commit
```
Notice that any "cleanly" merged changes (i.e., changes that did not result in conflict) are automatically staged into the index for you.

Don't worry about accidentally trying to committing files that contain conflicts; `git` won't let you:
```
  <edit other.c>
  $ git add other.c
  $ git pull
  <conflict involving foobar.c occurs during merge>
  $ git commit
  foobar.c: needs merge
```